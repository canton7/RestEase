using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Net.Http;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using RestEase.Platform;

namespace RestEase.Implementation
{
    /// <summary>
    /// Helper class used to generate interface implementations. Exposed for testing (and very adventurous people) only.
    /// </summary>
    public class ImplementationBuilder
    {
        private static readonly Regex pathParamMatch = new Regex(@"\{(.+?)\}");

        private static readonly string moduleBuilderName = "RestEaseAutoGeneratedModule";

        private static readonly MethodInfo requestVoidAsyncMethod = typeof(IRequester).GetTypeInfo().GetMethod("RequestVoidAsync");
        private static readonly MethodInfo requestAsyncMethod = typeof(IRequester).GetTypeInfo().GetMethod("RequestAsync");
        private static readonly MethodInfo requestWithResponseMessageAsyncMethod = typeof(IRequester).GetTypeInfo().GetMethod("RequestWithResponseMessageAsync");
        private static readonly MethodInfo requestWithResponseAsyncMethod = typeof(IRequester).GetTypeInfo().GetMethod("RequestWithResponseAsync");
        private static readonly MethodInfo requestRawAsyncMethod = typeof(IRequester).GetTypeInfo().GetMethod("RequestRawAsync");
        private static readonly ConstructorInfo requestInfoCtor = typeof(RequestInfo).GetTypeInfo().GetConstructor(new[] { typeof(HttpMethod), typeof(string) });
        private static readonly MethodInfo cancellationTokenSetter = typeof(RequestInfo).GetTypeInfo().GetProperty("CancellationToken").SetMethod;
        private static readonly MethodInfo allowAnyStatusCodeSetter = typeof(RequestInfo).GetTypeInfo().GetProperty("AllowAnyStatusCode").SetMethod;
        
        // These two methods have the same signature, which is very useful...
        private static readonly MethodInfo addQueryParameterMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddQueryParameter");
        private static readonly MethodInfo addQueryCollectionParameterMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddQueryCollectionParameter");

        private static readonly MethodInfo addQueryMapMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddQueryMap");
        private static readonly MethodInfo addQueryCollectionMapMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddQueryCollectionMap");
        private static readonly MethodInfo addRawQueryParameterMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddRawQueryParameter");
        private static readonly MethodInfo addPathParameterMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddPathParameter");
        private static readonly MethodInfo addPathPropertyMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddPathProperty");
        private static readonly MethodInfo setClassHeadersMethod = typeof(RequestInfo).GetTypeInfo().GetProperty("ClassHeaders").SetMethod;
        private static readonly MethodInfo addPropertyHeaderMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddPropertyHeader");
        private static readonly MethodInfo addMethodHeaderMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddMethodHeader");
        private static readonly MethodInfo addHeaderParameterMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("AddHeaderParameter");
        private static readonly MethodInfo setBodyParameterInfoMethod = typeof(RequestInfo).GetTypeInfo().GetMethod("SetBodyParameterInfo");
        private static readonly ConstructorInfo listOfKvpOfStringNCtor = typeof(List<KeyValuePair<string, string>>).GetTypeInfo().GetConstructor(new[] { typeof(int) });
        private static readonly MethodInfo listOfKvpOfStringAdd = typeof(List<KeyValuePair<string, string>>).GetTypeInfo().GetMethod("Add");
        private static readonly ConstructorInfo kvpOfStringCtor = typeof(KeyValuePair<string, string>).GetTypeInfo().GetConstructor(new[] { typeof(string), typeof(string) });
        private static readonly ConstructorInfo httpMethodCtor = typeof(HttpMethod).GetTypeInfo().GetConstructor(new[] { typeof(string) });

        private static readonly MethodInfo disposeMethod = typeof(IDisposable).GetTypeInfo().GetMethod("Dispose");

        private static readonly Dictionary<HttpMethod, PropertyInfo> httpMethodProperties = new Dictionary<HttpMethod, PropertyInfo>()
        {
            { HttpMethod.Delete, typeof(HttpMethod).GetTypeInfo().GetProperty("Delete") },
            { HttpMethod.Get, typeof(HttpMethod).GetTypeInfo().GetProperty("Get") },
            { HttpMethod.Head, typeof(HttpMethod).GetTypeInfo().GetProperty("Head") },
            { HttpMethod.Options, typeof(HttpMethod).GetTypeInfo().GetProperty("Options") },
            { HttpMethod.Post, typeof(HttpMethod).GetTypeInfo().GetProperty("Post") },
            { HttpMethod.Put, typeof(HttpMethod).GetTypeInfo().GetProperty("Put") },
            { HttpMethod.Trace, typeof(HttpMethod).GetTypeInfo().GetProperty("Trace") },
            { PatchAttribute.PatchMethod, typeof(PatchAttribute).GetTypeInfo().GetProperty("PatchMethod") },
        };

        private readonly ModuleBuilder moduleBuilder;

        private readonly object implementationBuilderLockObject = new object();
        private readonly ConcurrentDictionary<RuntimeTypeHandle, Func<IRequester, object>> creatorCache = new ConcurrentDictionary<RuntimeTypeHandle, Func<IRequester, object>>();

        /// <summary>
        /// Initialises a new instance of the <see cref="ImplementationBuilder"/> class
        /// </summary>
        public ImplementationBuilder()
        {
            var assemblyName = new AssemblyName(RestClient.FactoryAssemblyName);
            var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);

            var moduleBuilder = assemblyBuilder.DefineDynamicModule(moduleBuilderName);
            this.moduleBuilder = moduleBuilder;
        }

        /// <summary>
        /// Create an implementation of the given interface, using the given requester
        /// </summary>
        /// <typeparam name="T">Type of interface to implement</typeparam>
        /// <param name="requester">Requester to be used by the generated implementation</param>
        /// <returns>An implementation of the given interface</returns>
        public T CreateImplementation<T>(IRequester requester)
        {
            return (T)CreateImplementation(typeof(T), requester);
        }

        /// <summary>
        /// Create an implementation of the given interface, using the given requester
        /// </summary>
        /// <param name="type">Type of interface to implement</param>
        /// <param name="requester">Requester to be used by the generated implementation</param>
        /// <returns>An implementation of the given interface</returns>
        public object CreateImplementation(Type type, IRequester requester)
        {
            if (requester == null)
                throw new ArgumentNullException(nameof(requester));

            // We have to be careful here. The common case is going to be fetching an existing creator. However in the case
            // that one doesn't yet exist, we can't try and create two of the same type at the same time.
            // We have a lock around creating all types, as that's simpler and probably won't be noticable in practice.

            var key = type.TypeHandle;

            if (!this.creatorCache.TryGetValue(key, out Func<IRequester, object> creator))
            {
                lock (this.implementationBuilderLockObject)
                {
                    // Two threads can fail the TryGetValue and acquire this lock in order. The first one will create the type.
                    // Therefore the second one has to check for this...
                    if (!this.creatorCache.TryGetValue(key, out creator))
                    {
                        var implementationType = this.BuildImplementationImpl(type);
                        creator = this.BuildCreator(implementationType);
                        this.creatorCache.TryAdd(key, creator);
                    }
                }
            }

            return creator(requester);
        }

        private Func<IRequester, object> BuildCreator(Type implementationType)
        {
            var requesterParam = Expression.Parameter(typeof(IRequester));
            var ctor = Expression.New(implementationType.GetTypeInfo().GetConstructor(new[] { typeof(IRequester) }), requesterParam);
            return Expression.Lambda<Func<IRequester, object>>(ctor, requesterParam).Compile();
        }

        private Type BuildImplementationImpl(Type interfaceType)
        {
            var interfaceTypeInfo = interfaceType.GetTypeInfo();

            if (!interfaceTypeInfo.IsInterface)
                throw new ArgumentException(String.Format("Type {0} is not an interface", interfaceType.Name), nameof(interfaceType));

            var typeBuilder = this.moduleBuilder.DefineType(this.CreateImplementationName(interfaceType), TypeAttributes.Public | TypeAttributes.Sealed);
            typeBuilder.AddInterfaceImplementation(interfaceType);

            var classHeaders = InterfaceAndChildren(interfaceType, x => x.GetTypeInfo().GetCustomAttributes<HeaderAttribute>()).ToArray();
            var firstHeaderWithoutValue = classHeaders.FirstOrDefault(x => x.Value == null);
            if (firstHeaderWithoutValue != null)
                throw new ImplementationCreationException(String.Format("[Header(\"{0}\")] on interface must have the form [Header(\"Name\", \"Value\")]", firstHeaderWithoutValue.Name));
            var firstHeaderWithColon = classHeaders.FirstOrDefault(x => x.Name.Contains(":"));
            if (firstHeaderWithColon != null)
                throw new ImplementationCreationException(String.Format("[Header(\"{0}\", \"{1}\")] on interface must not have a colon in the header name", firstHeaderWithColon.Name, firstHeaderWithColon.Value));

            var classAllowAnyStatusCodeAttribute = interfaceTypeInfo.GetCustomAttribute<AllowAnyStatusCodeAttribute>();
            var classSerializationMethodsAttribute = interfaceTypeInfo.GetCustomAttribute<SerializationMethodsAttribute>();

            foreach (var childInterfaceType in interfaceTypeInfo.GetInterfaces())
            {
                if (childInterfaceType.GetTypeInfo().GetCustomAttribute<AllowAnyStatusCodeAttribute>() != null)
                    throw new ImplementationCreationException(String.Format("Parent interface {0} may not have any [AllowAnyStatusCode] attributes", childInterfaceType.Name));
            }

            // Define a readonly field which holds a reference to the IRequester
            var requesterField = typeBuilder.DefineField("requester", typeof(IRequester), FieldAttributes.Private | FieldAttributes.InitOnly);

            this.AddInstanceCtor(typeBuilder, requesterField);

            // If there are any class headers, define a static readonly field which contains them
            // Also define a static constructor to initialise it
            FieldBuilder classHeadersField = null;
            if (classHeaders.Length > 0)
            {
                classHeadersField = typeBuilder.DefineField("classHeaders", typeof(List<KeyValuePair<string, string>>), FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.InitOnly);
                this.AddStaticCtor(typeBuilder, classHeaders, classHeadersField);
            }

            this.HandleEvents(interfaceType);
            var properties = this.HandleProperties(typeBuilder, interfaceType);

            this.HandleMethods(typeBuilder, interfaceType, requesterField, classHeadersField, classAllowAnyStatusCodeAttribute, classSerializationMethodsAttribute, properties);

            Type constructedType;
            try
            {
                constructedType = typeBuilder.CreateTypeInfo().AsType();
            }
            catch (TypeLoadException e)
            {
                var msg = String.Format("Unable to create implementation for interface {0}. Ensure that the interface is public, or add [assembly: InternalsVisibleTo(RestClient.FactoryAssemblyName)] to your AssemblyInfo.cs", interfaceType.FullName);
                throw new ImplementationCreationException(msg, e);
            }

            return constructedType;
        }

        private void AddFriendlierNameForType(StringBuilder sb, Type type)
        {
            var typeInfo = type.GetTypeInfo();
            if (typeInfo.IsGenericType)
            {
                sb.Append(type.GetGenericTypeDefinition().FullName.Replace('.', '+'));
                sb.Append("<>["); // Just so that they can't fool us with carefully-crafted interface names...
                foreach (var arg in typeInfo.GetGenericArguments())
                {
                    this.AddFriendlierNameForType(sb, arg);
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(type.FullName.Replace('.', '+'));
            }
        }

        private string CreateImplementationName(Type interfaceType)
        {
            var sb = new StringBuilder();
            // Make this unspeakable, just in case...
            sb.Append("RestEase.AutoGenerated.<>");
            this.AddFriendlierNameForType(sb, interfaceType);
            return sb.ToString();
        }

        private void AddInstanceCtor(TypeBuilder typeBuilder, FieldBuilder requesterField)
        {
            // Add a constructor which takes the IRequester and assigns it to the field
            // public Name(IRequester requester)
            // {
            //     this.requester = requester;
            // }
            var ctorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new[] { typeof(IRequester) });
            var ctorIlGenerator = ctorBuilder.GetILGenerator();
            // Load 'this' and the requester onto the stack
            ctorIlGenerator.Emit(OpCodes.Ldarg_0);
            ctorIlGenerator.Emit(OpCodes.Ldarg_1);
            // Store the requester into this.requester
            ctorIlGenerator.Emit(OpCodes.Stfld, requesterField);
            ctorIlGenerator.Emit(OpCodes.Ret);
        }

        private void AddStaticCtor(TypeBuilder typeBuilder, HeaderAttribute[] classHeaders, FieldBuilder classHeadersField)
        {
            // static Name()
            // {
            //     classHeaders = new List<KeyValuePair<string>>(n);
            //     classHeaders.Add(new KeyValuePair<string, string>("name", "value"));
            //     ...
            // }

            var staticCtorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Static, CallingConventions.Standard, new Type[0]);
            var staticCtorIlGenerator = staticCtorBuilder.GetILGenerator();

            // Load the list size onto the stack
            // Stack: [list size]
            staticCtorIlGenerator.Emit(OpCodes.Ldc_I4, classHeaders.Length);
            // Ctor the list
            // Stack: [list]
            staticCtorIlGenerator.Emit(OpCodes.Newobj, listOfKvpOfStringNCtor);
            // Load each class header into the list
            foreach (var classHeader in classHeaders)
            {
                staticCtorIlGenerator.Emit(OpCodes.Dup);
                staticCtorIlGenerator.Emit(OpCodes.Ldstr, classHeader.Name);
                staticCtorIlGenerator.Emit(OpCodes.Ldstr, classHeader.Value); // This value can never be null - we assert that earlier
                staticCtorIlGenerator.Emit(OpCodes.Newobj, kvpOfStringCtor);
                staticCtorIlGenerator.Emit(OpCodes.Callvirt, listOfKvpOfStringAdd);
            }
            // Finally, store the list in its static field
            staticCtorIlGenerator.Emit(OpCodes.Stsfld, classHeadersField);
            staticCtorIlGenerator.Emit(OpCodes.Ret);
        }

        private void HandleMethods(
            TypeBuilder typeBuilder,
            Type interfaceType,
            FieldBuilder requesterField,
            FieldInfo classHeadersField,
            AllowAnyStatusCodeAttribute classAllowAnyStatusCodeAttribute,
            SerializationMethodsAttribute classSerializationMethodsAttribute,
            PropertyGrouping properties)
        {
            foreach (var methodInfo in InterfaceAndChildren(interfaceType, x => x.GetTypeInfo().GetMethods()))
            {
                // Exclude property getter / setters, etc
                if (methodInfo.IsSpecialName)
                    continue;

                var parameters = methodInfo.GetParameters();
                var parameterGrouping = new ParameterGrouping(parameters, methodInfo.Name);

                var methodBuilder = typeBuilder.DefineMethod(methodInfo.Name, MethodAttributes.Public | MethodAttributes.Virtual, methodInfo.ReturnType, parameters.Select(x => x.ParameterType).ToArray());
                var methodIlGenerator = methodBuilder.GetILGenerator();

                if (methodInfo == disposeMethod)
                {
                    this.AddDisposeMethod(methodIlGenerator, requesterField);
                }
                else
                {
                    var requestAttribute = methodInfo.GetCustomAttribute<RequestAttribute>();
                    if (requestAttribute == null)
                        throw new ImplementationCreationException(String.Format("Method {0} does not have a suitable [Get] / [Post] / etc attribute on it", methodInfo.Name));

                    var allowAnyStatusCodeAttribute = methodInfo.GetCustomAttribute<AllowAnyStatusCodeAttribute>();

                    var methodSerializationMethodsAttribute = methodInfo.GetCustomAttribute<SerializationMethodsAttribute>();
                    var serializationMethods = new ResolvedSerializationMethods(classSerializationMethodsAttribute, methodSerializationMethodsAttribute);

                    this.ValidatePathParams(requestAttribute.Path, parameterGrouping.PathParameters.Select(x => x.Attribute.Name ?? x.Parameter.Name).ToList(), properties.Path.Select(x => x.Attribute.Name).ToList(), methodInfo.Name);

                    this.AddRequestInfoCreation(methodIlGenerator, requesterField, requestAttribute);
                    this.AddCancellationTokenIfNeeded(methodIlGenerator, parameterGrouping.CancellationToken);
                    this.AddClassHeadersIfNeeded(methodIlGenerator, classHeadersField);
                    this.AddPropertyHeaders(methodIlGenerator, properties.Headers);
                    this.AddPathProperties(methodIlGenerator, properties.Path);
                    this.AddMethodHeaders(methodIlGenerator, methodInfo);
                    this.AddAllowAnyStatusCodeIfNecessary(methodIlGenerator, allowAnyStatusCodeAttribute ?? classAllowAnyStatusCodeAttribute);
                    this.AddParameters(methodIlGenerator, parameterGrouping, methodInfo.Name, serializationMethods);
                    this.AddRequestMethodInvocation(methodIlGenerator, methodInfo);

                    // Finally, return
                    methodIlGenerator.Emit(OpCodes.Ret);

                    typeBuilder.DefineMethodOverride(methodBuilder, methodInfo);
                }
            }
        }

        private void HandleEvents(Type interfaceType)
        {
            if (InterfaceAndChildren(interfaceType, x => x.GetTypeInfo().GetEvents()).Any())
                throw new ImplementationCreationException("Interfaces must not have any events");
        }

        private PropertyGrouping HandleProperties(TypeBuilder typeBuilder, Type interfaceType)
        {
            var grouping = new PropertyGrouping(InterfaceAndChildren(interfaceType, x => x.GetTypeInfo().GetProperties()));
            MethodAttributes attributes = MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.SpecialName;

            foreach (var property in grouping.AllProperties)
            {
                var propertyBuilder = typeBuilder.DefineProperty(property.PropertyInfo.Name, PropertyAttributes.None, property.PropertyInfo.PropertyType, null);
                var getter = typeBuilder.DefineMethod(property.PropertyInfo.GetMethod.Name, attributes, property.PropertyInfo.PropertyType, new Type[0]);
                var setter = typeBuilder.DefineMethod(property.PropertyInfo.SetMethod.Name, attributes, null, new Type[] { property.PropertyInfo.PropertyType });
                var backingField = typeBuilder.DefineField("bk_" + property.PropertyInfo.Name, property.PropertyInfo.PropertyType, FieldAttributes.Private);

                var getterIlGenerator = getter.GetILGenerator();
                getterIlGenerator.Emit(OpCodes.Ldarg_0);
                getterIlGenerator.Emit(OpCodes.Ldfld, backingField);
                getterIlGenerator.Emit(OpCodes.Ret);
                propertyBuilder.SetGetMethod(getter);

                var setterIlGenerator = setter.GetILGenerator();
                setterIlGenerator.Emit(OpCodes.Ldarg_0);
                setterIlGenerator.Emit(OpCodes.Ldarg_1);
                setterIlGenerator.Emit(OpCodes.Stfld, backingField);
                setterIlGenerator.Emit(OpCodes.Ret);
                propertyBuilder.SetSetMethod(setter);

                property.BackingField = backingField;
            }

            return grouping;
        }

        private void AddDisposeMethod(ILGenerator methodIlGenerator, FieldBuilder requesterField)
        {
            methodIlGenerator.Emit(OpCodes.Ldarg_0);
            methodIlGenerator.Emit(OpCodes.Ldfld, requesterField);
            methodIlGenerator.Emit(OpCodes.Callvirt, disposeMethod);
            methodIlGenerator.Emit(OpCodes.Ret);
        }

        private void AddRequestInfoCreation(ILGenerator methodIlGenerator, FieldBuilder requesterField, RequestAttribute requestAttribute)
        {
            // Load 'this' onto the stack
            // Stack: [this]
            methodIlGenerator.Emit(OpCodes.Ldarg_0);
            // Load 'this.requester' onto the stack
            // Stack: [this.requester]
            methodIlGenerator.Emit(OpCodes.Ldfld, requesterField);

            // Start loading the ctor params for RequestInfo onto the stack
            // 1. HttpMethod
            // Stack: [this.requester, HttpMethod]
            // For the standard HTTP methods, we can get a static instance. For others, we'll need to construct the HttpMethod
            // ourselves
            if (httpMethodProperties.TryGetValue(requestAttribute.Method, out PropertyInfo cachedPropertyInfo))
            {
                methodIlGenerator.Emit(OpCodes.Call, cachedPropertyInfo.GetMethod);
            }
            else
            {
                methodIlGenerator.Emit(OpCodes.Ldstr, requestAttribute.Method.Method);
                methodIlGenerator.Emit(OpCodes.Newobj, httpMethodCtor);
            }
            // 2. The Path
            // Stack: [this.requester, HttpMethod, path]
            methodIlGenerator.Emit(OpCodes.Ldstr, requestAttribute.Path ?? String.Empty);

            // Ctor the RequestInfo
            // Stack: [this.requester, requestInfo]
            methodIlGenerator.Emit(OpCodes.Newobj, requestInfoCtor);
        }

        private void AddCancellationTokenIfNeeded(ILGenerator methodIlGenerator, IndexedParameter? cancellationToken)
        {
            if (cancellationToken.HasValue)
            {
                methodIlGenerator.Emit(OpCodes.Dup);
                methodIlGenerator.Emit(OpCodes.Ldarg, (short)cancellationToken.Value.Index);
                methodIlGenerator.Emit(OpCodes.Callvirt, cancellationTokenSetter);
            }
        }

        private void AddClassHeadersIfNeeded(ILGenerator methodIlGenerator, FieldInfo classHeadersField)
        {
            if (classHeadersField != null)
            {
                // requestInfo.ClassHeaders = classHeaders
                methodIlGenerator.Emit(OpCodes.Dup);
                methodIlGenerator.Emit(OpCodes.Ldsfld, classHeadersField);
                methodIlGenerator.Emit(OpCodes.Callvirt, setClassHeadersMethod);
            }
        }

        private void AddPropertyHeaders(ILGenerator methodIlGenerator, List<AttributedProperty<HeaderAttribute>> headers)
        {
            foreach (var propertyHeader in headers)
            {
                var typedMethod = addPropertyHeaderMethod.MakeGenericMethod(propertyHeader.BackingField.FieldType);
                methodIlGenerator.Emit(OpCodes.Dup);
                methodIlGenerator.Emit(OpCodes.Ldstr, propertyHeader.Attribute.Name);
                methodIlGenerator.Emit(OpCodes.Ldarg_0);
                methodIlGenerator.Emit(OpCodes.Ldfld, propertyHeader.BackingField);
                if (propertyHeader.Attribute.Value == null)
                    methodIlGenerator.Emit(OpCodes.Ldnull);
                else
                    methodIlGenerator.Emit(OpCodes.Ldstr, propertyHeader.Attribute.Value);
                methodIlGenerator.Emit(OpCodes.Callvirt, typedMethod);
            }
        }

        private void AddPathProperties(ILGenerator methodIlGenerator, List<AttributedProperty<PathAttribute>> path)
        {
            foreach (var pathProperty in path)
            {
                var typedMethod = addPathPropertyMethod.MakeGenericMethod(pathProperty.BackingField.FieldType);
                methodIlGenerator.Emit(OpCodes.Dup);
                methodIlGenerator.Emit(OpCodes.Ldstr, pathProperty.Attribute.Name);
                methodIlGenerator.Emit(OpCodes.Ldarg_0);
                methodIlGenerator.Emit(OpCodes.Ldfld, pathProperty.BackingField);
                if (pathProperty.Attribute.Format == null)
                    methodIlGenerator.Emit(OpCodes.Ldnull);
                else
                    methodIlGenerator.Emit(OpCodes.Ldstr, pathProperty.Attribute.Format);
                methodIlGenerator.Emit(pathProperty.Attribute.UrlEncode ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
                methodIlGenerator.Emit(OpCodes.Callvirt, typedMethod);
            }
        }

        private void AddMethodHeaders(ILGenerator methodIlGenerator, MethodInfo methodInfo)
        {
            var methodHeaders = methodInfo.GetCustomAttributes<HeaderAttribute>();
            foreach (var methodHeader in methodHeaders)
            {
                if (methodHeader.Name.Contains(":"))
                    throw new ImplementationCreationException(String.Format("[Header(\"{0}\")] on method {1} must not have colon in its name", methodHeader.Name, methodInfo.Name));
                this.AddMethodHeader(methodIlGenerator, methodHeader);
            }
        }

        private void AddAllowAnyStatusCodeIfNecessary(ILGenerator methodIlGenerator, AllowAnyStatusCodeAttribute resolvedAllowAnyStatusCodeAttribute)
        {
            if (resolvedAllowAnyStatusCodeAttribute != null && resolvedAllowAnyStatusCodeAttribute.AllowAnyStatusCode)
            {
                methodIlGenerator.Emit(OpCodes.Dup);
                methodIlGenerator.Emit(OpCodes.Ldc_I4_1);
                methodIlGenerator.Emit(OpCodes.Callvirt, allowAnyStatusCodeSetter);
            }
        }

        private void AddParameters(
            ILGenerator methodIlGenerator,
            ParameterGrouping parameterGrouping,
            string methodName,
            ResolvedSerializationMethods serializationMethods)
        {
            // If there's a body, add it
            if (parameterGrouping.Body != null)
            {
                var body = parameterGrouping.Body.Value;
                this.AddBody(methodIlGenerator, serializationMethods.ResolveBody(body.Attribute.SerializationMethod), body.Parameter.ParameterType, (short)body.Index);
            }

            // If there's a query map, add it
            foreach (var queryMap in parameterGrouping.QueryMaps)
            {
                var method = MakeQueryMapMethodInfo(queryMap.Parameter.ParameterType);
                if (method == null)
                    throw new ImplementationCreationException(String.Format("Method '{0}': [QueryMap] parameter is not of type IDictionary or IDictionary<TKey, TValue> (or one of their descendents)", methodName));
                this.AddQueryMap(methodIlGenerator, queryMap.Parameter.ParameterType, (short)queryMap.Index, method, serializationMethods.ResolveQuery(queryMap.Attribute.SerializationMethod));
            }

            foreach (var queryParameter in parameterGrouping.QueryParameters)
            {
                var method = MakeQueryParameterMethodInfo(queryParameter.Parameter.ParameterType);
                this.AddQueryParam(methodIlGenerator, queryParameter.Attribute.HasName ? queryParameter.Attribute.Name : queryParameter.Parameter.Name, (short)queryParameter.Index, queryParameter.Attribute.Format, method, serializationMethods.ResolveQuery(queryParameter.Attribute.SerializationMethod));
            }

            foreach (var plainParameter in parameterGrouping.PlainParameters)
            {
                var method = MakeQueryParameterMethodInfo(plainParameter.Parameter.ParameterType);
                this.AddQueryParam(methodIlGenerator, plainParameter.Parameter.Name, (short)plainParameter.Index, null, method, serializationMethods.ResolveQuery(QuerySerializationMethod.Default));
            }

            if (parameterGrouping.RawQueryString != null)
            {
                var parameter = parameterGrouping.RawQueryString.Value;
                var method = addRawQueryParameterMethod.MakeGenericMethod(parameter.Parameter.ParameterType);
                this.AddRawQueryParam(methodIlGenerator, (short)parameter.Index, method);
            }

            foreach (var pathParameter in parameterGrouping.PathParameters)
            {
                this.AddPathParam(methodIlGenerator, pathParameter);
            }

            foreach (var headerParameter in parameterGrouping.HeaderParameters)
            {
                if (headerParameter.Attribute.Value != null)
                    throw new ImplementationCreationException(String.Format("Method '{0}': [Header(\"{1}\", \"{2}\")] must have the form [Header(\"Name\")], not [Header(\"Name\", \"Value\")]", methodName, headerParameter.Attribute.Name, headerParameter.Attribute.Value));
                if (headerParameter.Attribute.Name.Contains(":"))
                    throw new ImplementationCreationException(String.Format("Method '{0}': [Header(\"{1}\")] must not have a colon in its name", methodName, headerParameter.Attribute.Name));
                var typedMethod = addHeaderParameterMethod.MakeGenericMethod(headerParameter.Parameter.ParameterType);
                this.AddHeaderParameter(methodIlGenerator, headerParameter.Attribute.Name, (short)headerParameter.Index, typedMethod);
            }
        }

        private static MethodInfo MakeQueryParameterMethodInfo(Type parameterType)
        {
            Type typeOfT = null;
            // Don't want to count string as an IEnumrable<char>...
            if (parameterType != typeof(string))
                typeOfT = CollectionTypeOfType(parameterType);

            // Does not implement IEnumerable<T>
            if (typeOfT == null)
                return addQueryParameterMethod.MakeGenericMethod(parameterType);
            else
                return addQueryCollectionParameterMethod.MakeGenericMethod(typeOfT);
        }

        private static MethodInfo MakeQueryMapMethodInfo(Type queryMapType)
        {
            var nullableDictionaryTypes = DictionaryTypesOfType(queryMapType);
            if (nullableDictionaryTypes == null)
                return null;

            var dictionaryTypes = nullableDictionaryTypes.Value;

            Type typeOfT = null;
            // Don't want to count string as an IEnumrable<char>...
            if (dictionaryTypes.Value != typeof(string))
                typeOfT = CollectionTypeOfType(dictionaryTypes.Value);

            if (typeOfT == null)
                return addQueryMapMethod.MakeGenericMethod(dictionaryTypes.Key, dictionaryTypes.Value);
            else
                return addQueryCollectionMapMethod.MakeGenericMethod(dictionaryTypes.Key, dictionaryTypes.Value, typeOfT);
        }

        private static Type CollectionTypeOfType(Type input)
        {
            foreach (var baseType in EnumerableExtensions.Concat(input, input.GetTypeInfo().GetInterfaces()))
            {
                if (baseType.GetTypeInfo().IsGenericType && baseType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                    return baseType.GetTypeInfo().GetGenericArguments()[0];
            }

            return null;
        }

        private static KeyValuePair<Type, Type>? DictionaryTypesOfType(Type input)
        {
            foreach (var baseType in EnumerableExtensions.Concat(input, input.GetTypeInfo().GetInterfaces()))
            {
                if (baseType.GetTypeInfo().IsGenericType && baseType.GetGenericTypeDefinition() == typeof(IDictionary<,>))
                {
                    var genericArguments = baseType.GetTypeInfo().GetGenericArguments();
                    return new KeyValuePair<Type, Type>(genericArguments[0], genericArguments[1]);
                }
            }

            return null;
        }

        private void AddRequestMethodInvocation(ILGenerator methodIlGenerator, MethodInfo methodInfo)
        { 
            // Call the appropriate RequestVoidAsync/RequestAsync method, depending on whether or not we have a return type
            if (methodInfo.ReturnType == typeof(Task))
            {
                // Stack: [Task]
                methodIlGenerator.Emit(OpCodes.Callvirt, requestVoidAsyncMethod);
            }
            else if (methodInfo.ReturnType.GetTypeInfo().IsGenericType && methodInfo.ReturnType.GetGenericTypeDefinition() == typeof(Task<>))
            {
                var typeOfT = methodInfo.ReturnType.GetTypeInfo().GetGenericArguments()[0];
                // Now, is it a Task<HttpResponseMessage>, a Task<string>, a Task<Response<T>> or a Task<T>?
                if (typeOfT == typeof(HttpResponseMessage))
                {
                    // Stack: [Task<HttpResponseMessage>]
                    methodIlGenerator.Emit(OpCodes.Callvirt, requestWithResponseMessageAsyncMethod);
                }
                else if (typeOfT == typeof(string))
                {
                    // Stack: [Task<string>]
                    methodIlGenerator.Emit(OpCodes.Callvirt, requestRawAsyncMethod);
                }
                else if (typeOfT.GetTypeInfo().IsGenericType && typeOfT.GetGenericTypeDefinition() == typeof(Response<>))
                {
                    // Stack: [Task<Response<T>>]
                    var typedRequestWithResponseAsyncMethod = requestWithResponseAsyncMethod.MakeGenericMethod(typeOfT.GetTypeInfo().GetGenericArguments()[0]);
                    methodIlGenerator.Emit(OpCodes.Callvirt, typedRequestWithResponseAsyncMethod);
                }
                else
                {
                    // Stack: [Task<T>]
                    var typedRequestAsyncMethod = requestAsyncMethod.MakeGenericMethod(typeOfT);
                    methodIlGenerator.Emit(OpCodes.Callvirt, typedRequestAsyncMethod);
                }
            }
            else
            {
                throw new ImplementationCreationException(String.Format("Method '{0}': must have a return type of Task<T> or Task", methodInfo.Name));
            }
        }

        private void AddBody(ILGenerator methodIlGenerator, BodySerializationMethod serializationMethod, Type parameterType, short parameterIndex)
        {
            // Equivalent C#:
            // requestInfo.SetBodyParameterInfo(serializationMethod, value)
            var typedMethod = setBodyParameterInfoMethod.MakeGenericMethod(parameterType);

            // Stack: [..., requestInfo, requestInfo]
            methodIlGenerator.Emit(OpCodes.Dup);
            // Stack: [..., requestInfo, requestInfo, serializationMethod]
            methodIlGenerator.Emit(OpCodes.Ldc_I4, (int)serializationMethod);
            // Stack: [..., requestInfo, requestInfo, serializationMethod, parameter]
            methodIlGenerator.Emit(OpCodes.Ldarg, parameterIndex);
            // Stack: [..., requestInfo]
            methodIlGenerator.Emit(OpCodes.Callvirt, typedMethod);
        }

        private void AddQueryMap(ILGenerator methodIlGenerator, Type parameterType, short parameterIndex, MethodInfo method, QuerySerializationMethod serializationMethod)
        {
            // Equivalent C#:
            // requestInfo.AddQueryMap<TKey, TValue>(value) or requestInfo.AddQueryMap<TKey, TValue, TElement>(value)
            // They might possible potentially provide a struct here (although it's unlikely), so we need to box

            methodIlGenerator.Emit(OpCodes.Dup);
            // Load the serialization method onto the stack
            // Stack: [..., requestInfo, requestInfo, serializationMethod]
            methodIlGenerator.Emit(OpCodes.Ldc_I4, (int)serializationMethod);
            methodIlGenerator.Emit(OpCodes.Ldarg, parameterIndex);
            if (parameterType.GetTypeInfo().IsValueType)
                methodIlGenerator.Emit(OpCodes.Box);
            methodIlGenerator.Emit(OpCodes.Callvirt, method);
        }

        private void AddMethodHeader(ILGenerator methodIlGenerator, HeaderAttribute header)
        {
            // Equivalent C#:
            // requestInfo.AddMethodHeader("name", "value");

            // Stack: [..., requestInfo, requestInfo]
            methodIlGenerator.Emit(OpCodes.Dup);
            // Stack: [..., requestInfo, requestInfo, "name"]
            methodIlGenerator.Emit(OpCodes.Ldstr, header.Name);
            // Stack: [..., requestInfo, requestInfo, "name", "value"]
            if (header.Value == null)
                methodIlGenerator.Emit(OpCodes.Ldnull);
            else
                methodIlGenerator.Emit(OpCodes.Ldstr, header.Value);
            // Stack: [..., requestInfo]
            methodIlGenerator.Emit(OpCodes.Callvirt, addMethodHeaderMethod);
        }

        private void AddQueryParam(ILGenerator methodIlGenerator, string name, short parameterIndex, string format, MethodInfo methodToCall, QuerySerializationMethod serializationMethod)
        {
            // Equivalent C#:
            // requestInfo.AddQueryParameter(serializationMethod, name, value, format) (or AddQueryCollectionParameter)

            // Stack: [..., requestInfo, requestInfo]
            methodIlGenerator.Emit(OpCodes.Dup);
            // Load the serialization method onto the stack
            // Stack: [..., requestInfo, requestInfo, serializationMethod]
            methodIlGenerator.Emit(OpCodes.Ldc_I4, (int)serializationMethod);
            // Load the name onto the stack
            // Stack: [..., requestInfo, requestInfo, serializationMethod, name]
            if (name == null)
                methodIlGenerator.Emit(OpCodes.Ldnull);
            else
                methodIlGenerator.Emit(OpCodes.Ldstr, name);
            // Load the param onto the stack
            // Stack: [..., requestInfo, requestInfo, serializationMethod, name, value]
            methodIlGenerator.Emit(OpCodes.Ldarg, parameterIndex);
            // Load the format onto the stack
            // Stack: [..., requestInfo, requestInfo, serializationMethod, name, value, format]
            if (format == null)
                methodIlGenerator.Emit(OpCodes.Ldnull);
            else
                methodIlGenerator.Emit(OpCodes.Ldstr, format);
            // Call AddPathParameter
            // Stack: [..., requestInfo]
            methodIlGenerator.Emit(OpCodes.Callvirt, methodToCall);
        }

        private void AddRawQueryParam(ILGenerator methodIlGenerator, short parameterIndex, MethodInfo methodInfo)
        {
            // Equivalent C#:
            // requestInfo.AddRawQueryParameter(value)

            // Stakc: [..., requestInfo, requestInfo]
            methodIlGenerator.Emit(OpCodes.Dup);
            // Load the param onto the stack
            // Stack: [..., requestInfo, requestInfo, value]
            methodIlGenerator.Emit(OpCodes.Ldarg, parameterIndex);
            // Call AddRawQueryParameter
            methodIlGenerator.Emit(OpCodes.Callvirt, methodInfo);
        }

        private void AddPathParam(ILGenerator methodIlGenerator, IndexedParameter<PathAttribute> pathParameter)
        {
            var methodInfo = addPathParameterMethod.MakeGenericMethod(pathParameter.Parameter.ParameterType);

            // Equivalent C#:
            // requestInfo.AddPathParameter("name", value, format, urlEncode);
            // where 'value' is the parameter at index parameterIndex

            // Duplicate the requestInfo.
            // Stack: [..., requestInfo, requestInfo]
            methodIlGenerator.Emit(OpCodes.Dup);
            // Load the name onto the stack
            // Stack: [..., requestInfo, requestInfo, name]
            methodIlGenerator.Emit(OpCodes.Ldstr, pathParameter.Attribute.Name ?? pathParameter.Parameter.Name);
            // Load the param onto the stack
            // Stack: [..., requestInfo, requestInfo, name, value]
            methodIlGenerator.Emit(OpCodes.Ldarg, (short)pathParameter.Index);
            // Load the format onto the stack
            // Stack: [..., requestInfo, requestInfo, name, value, format]
            if (pathParameter.Attribute.Format == null)
                methodIlGenerator.Emit(OpCodes.Ldnull);
            else
                methodIlGenerator.Emit(OpCodes.Ldstr, pathParameter.Attribute.Format);
            // Load urlEncode onto the stack
            // Stack: [..., requestInfo, requestInfo, name, value, format, urlEncode]
            methodIlGenerator.Emit(pathParameter.Attribute.UrlEncode ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            // Call AddPathParameter
            // Stack: [..., requestInfo]
            methodIlGenerator.Emit(OpCodes.Callvirt, methodInfo);
        }

        private void AddHeaderParameter(ILGenerator methodIlGenerator, string name, short parameterIndex, MethodInfo method)
        {
            // Equivalent C#:
            // requestInfo.AddHeaderParameter("name", value);
            // where 'value' is the parameter at index parameterIndex

            // Duplicate the requestInfo. This is because calling AddQueryParameter on it will pop it
            // Stack: [..., requestInfo, requestInfo]
            methodIlGenerator.Emit(OpCodes.Dup);
            // Load the name onto the stack
            // Stack: [..., requestInfo, requestInfo, name]
            methodIlGenerator.Emit(OpCodes.Ldstr, name);
            // Load the param onto the stack
            // Stack: [..., requestInfo, requestInfo, name, value]
            methodIlGenerator.Emit(OpCodes.Ldarg, parameterIndex);
            // Call AddPathParameter
            // Stack: [..., requestInfo]
            methodIlGenerator.Emit(OpCodes.Callvirt, method);
        }

        private void ValidatePathParams(string path, IEnumerable<string> pathParams, IEnumerable<string> propertyParams, string methodName)
        {
            if (path == null)
                path = String.Empty;

            // Check that there are no duplicate param names in the attributes
            var duplicateKey = pathParams.GroupBy(x => x).FirstOrDefault(x => x.Count() > 1);
            if (duplicateKey != null)
                throw new ImplementationCreationException(String.Format("Mathod '{0}': found more than one path parameter for key {1}.", methodName, duplicateKey));

            // Check that each placeholder has a matching attribute, and vice versa
            // We allow a property param to fill in for a missing path param, but we allow them to duplicate
            // each other (the path param takes precedence), and allow a property param which doesn't have a placeholder.
            var placeholders = pathParamMatch.Matches(path).Cast<Match>().Select(x => x.Groups[1].Value).ToList();

            var firstMissingParam = placeholders.Except(pathParams.Concat(propertyParams)).FirstOrDefault();
            if (firstMissingParam != null)
                throw new ImplementationCreationException(String.Format("Method '{0}': unable to find a [Path(\"{1}\")] property for the path parameter '{1}'.", methodName, firstMissingParam));

            var firstMissingPlaceholder = pathParams.Except(placeholders).FirstOrDefault();
            if (firstMissingPlaceholder != null)
                throw new ImplementationCreationException(String.Format("Method '{0}': unable to find to find a placeholder {{{1}}} for the path parameter '{1}'.", methodName, firstMissingPlaceholder));
        }

        private IEnumerable<T> InterfaceAndChildren<T>(Type interfaceType, Func<Type, IEnumerable<T>> selector)
        {
            foreach (var item in selector(interfaceType))
            {
                yield return item;
            }
            foreach (var child in interfaceType.GetTypeInfo().GetInterfaces())
            {
                foreach (var item in selector(child))
                {
                    yield return item;
                }
            }
        }
    }
}
